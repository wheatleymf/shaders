// Shader tutorial by wheatleymf
// "Shader Fundamentals ~ Pt.3: TEXTURES AND VARIABLES"
// You're free to use and modify this shader.

FEATURES
{
    #include "common/features.hlsl"
}

MODES
{
	VrForward();
	ToolsVis( S_MODE_TOOLS_VIS );
}   

COMMON
{
	#include "common/shared.hlsl"
}

struct VertexInput
{
	#include "common/vertexinput.hlsl"
};

struct PixelInput
{
	#include "common/pixelinput.hlsl"
};

VS
{
    #include "common/vertex.hlsl"

    // "MainVs" is the name of a main vertex shader function. It always must be MainVs.
    // VertexInput is the "unprocessed" vertex data that we're feeding into vertex shader. It is our input. 
    // PixelInput is a type that vertex shader will return. Object of this type will be sent to fragment shader.
    PixelInput MainVs( VertexInput i )
    {
        // Create PixelInput object, initialize it with our processed vertex.
        // Between ProcessVertex() and FinalizeVertex() you can do any sorts of tricks
        // with your vertices.
        PixelInput o = ProcessVertex( i );

        // Return finalized vertex
        return FinalizeVertex( o );
    }
}    

PS
{   
    // Defining this keyword will get rid of any unnecessary input slots generated by s&box
    #define CUSTOM_MATERIAL_INPUTS
    #include "common/pixel.hlsl"
    
    // Create a new 2D texture input slot with a name "AlbedoMap", read in sRGB color space,
    // with file suffix "_color", inside a UI group called "My Material" on 1st place, and default color 1,1,1 (white) 
    CreateInputTexture2D( AlbedoMap, Srgb, 8, "", "_color", "My Material,10/10", Default3( 1.0, 1.0, 1.0 ) );
    // Create a new Texture2D object, with RGB channels set to copy from input slot "AlbedoMap", with sRGB color space, 
    // compression format BC7, and uhh telling to read in sRGB format again. 
    Texture2D g_tColor < Channel( RGB, Box( AlbedoMap ), Srgb ); OutputFormat( BC7 ); SrgbRead( true ); >;

    // Add a float variable that will control the scale of our texture on a mesh.
    float TextureScale < UiType( Slider ); Range( 0, 5 ); Default( 1 ); UiGroup( "My Material,10/11" ); >;
    float3 TextureTint < UiType( Color ); Default3( 1, 1, 1 ); UiGroup( "My Material,10/12" ); >;

    // Add two float2 variables. Scroll Direction defines the scroll direction on each axis (X and Y), going either X+ or X- (or Y+ / Y-)
    // Scroll Speed will define the scrolling speed for each axis. 
    int2 TextureScrollDirection < UiType( Slider ); Range2( -1, -1, 1, 1 ); Default2( 0, 0 ); UiGroup( "Texture Scroll,20/10" ); >;
    float2 TextureScrollSpeed < UiType( Slider ); Range2( 0, 0, 4, 4 ); Default2( 1, 1 ); UiGroup( "Texture Scroll,20/20" ); >;

    float4 MainPs( PixelInput i ) : SV_Target0
    {
        // Create a new float2 variable with our texture coords, affected by TextureScale which will change the size of a texture. 
        // Then, use the shorthand operator to append animated texture offset. g_flTime is a global time variable.
        // After multiplying speed and time, we multiply it by direction. If it's zero, then total scroll offset
        // will be zero. If it's 1, then it'll keep scrolling in positive axis component. If it's -1, it'll 
        // go in opposite direction. 
        float2 uv = i.vTextureCoords * TextureScale;
        uv += g_flTime * TextureScrollSpeed * TextureScrollDirection;
        
        // Sample our texture2D with a common sampler state (anisotropic filter) and given texture coordinates.
        // Our texture2D has only RGB channels, so we'll use float3 for it. 
        float3 MyTexture = g_tColor.Sample( g_sAniso, uv ) * TextureTint;
    
        // Return a final pixel, with RGB values of our new texture, and forced opacity at 1. 
        return float4( MyTexture, 1 );
    }
}