// Shader tutorial by wheatleymf
// "Shader Fundamentals ~ Pt.10: VERTEX DISPLACEMENT"
// You're free to use and modify this shader.

FEATURES
{       
    #include "common/features.hlsl"
}

MODES
{
	VrForward();
    Depth();
}   

COMMON
{
	#include "common/shared.hlsl"
}

struct VertexInput
{
	#include "common/vertexinput.hlsl"

    // Extend VertexInput struct with additional property for vertex colors
    float4 vColor : COLOR0 < Semantic( Color ); >;
};

struct PixelInput
{
	#include "common/pixelinput.hlsl"
};

VS
{
    #include "common/vertex.hlsl"

    PixelInput MainVs( VertexInput i )
    {
        PixelInput o = ProcessVertex( i );
        o.vVertexColor.rgb = i.vColor.rgb;
        return FinalizeVertex( o );
    }
}    

PS
{   
    // Defining this keyword will get rid of any unnecessary input slots generated by s&box
    #define CUSTOM_MATERIAL_INPUTS
    #include "common/pixel.hlsl"

	//
	// Prepare inputs for all textures
	//
	CreateInputTexture2D( Color, 			Srgb, 	8, "", "_color", "Material A,10/Albedo Map,10/10", Default3( 1.0, 1.0, 1.0 ) );						
	CreateInputTexture2D( ColorTintMask, 	Linear, 8, "", "_tint", "Material A,10/Albedo Map,10/20", Default1( 1 ) );						
	CreateInputTexture2D( Normal, 			Linear, 8, "NormalizeNormals", "_normal", "Material A,10/Normal Map,10/30", Default3( 0.5, 0.5, 1.0 ) );		
    CreateInputTexture2D( Roughness, 		Linear, 8, "", "_rough", "Material A,10/Roughness,10/40", Default( 1 ) );											
	CreateInputTexture2D( Metalness, 		Linear, 8, "", "_metal",  "Material A,10/Metalness,10/50", Default( 0 ) );									
	CreateInputTexture2D( AmbientOcclusion, Linear, 8, "", "_ao",  "Material A,10/Ambient Occlusion,10/60", Default( 1 ) );
    CreateInputTexture2D( Opacity,          Linear, 8, "", "_alpha", "Material A,10/Opacity,10/70", Default( 1 ) );

	// 
	// Create Texture2D for all basic inputs
	// 
	Texture2D ColorMap  < Channel( RGB, Box( Color ), Srgb ); Channel( A, Box( ColorTintMask ), Linear ); OutputFormat( BC7 ); SrgbRead( true ); >;
	Texture2D NormalMap < Channel( RGB, Box( Normal ), Linear ); Channel( A, Box( Opacity ), Linear ); OutputFormat( DXT5 ); SrgbRead( false ); >; 
	Texture2D g_tRma    < Channel( R, Box( Roughness), Linear ); Channel( G, Box( Metalness ), Linear); Channel( B, Box( AmbientOcclusion ), Linear ); OutputFormat( BC7 ); SrgbRead ( false ); >; 

    // Control the intensity of a normal map 
    float g_flNormalIntensity < UiType( Slider ); Range( 0, 3 ); Default( 1 ); UiGroup("Material A,10/Normal Map,10/31"); >; 
    float g_flDistortionIntensity < UiType( Slider ); Range( 0, 8 ); Default( 1 ); UiGroup("Material A,10/Normal Map,10/32"); >; 
    
    // Buffer fog options
    float g_flFogEndDistanceWs < UiType( Slider ); Range( 0, 1024 ); Default( 512 ); UiGroup("Material A,10/Layer Settings,10/20"); >;
    float g_flFogDensity < UiType( Slider ); Range( 0, 1 ); Default( 1 ); UiGroup("Material A,10/Layer Settings,10/21"); >;
    float3 g_vFrameBufferFogColor < UiType( Color ); Default3( 1, 0, 0.5 ); UiGroup("Material A,10/Layer Settings,10/22"); >;

    // Texture scale & offset from the previous unlit shader
    int2    TextureScrollDirection < UiType( Slider ); Range2( -1, -1, 1, 1 ); Default2( 0, 0 ); UiGroup( "Settings,30/Scroll,30/10" ); >;
    float2  TextureScrollSpeed < UiType( Slider ); Range2( 0, 0, 4, 4 ); Default2( 1, 1 ); UiGroup( "Settings,30/Scroll,30/20" ); >;
    float   TextureScale < UiType( Slider ); Range( 0, 5 ); Default( 1 ); UiGroup( "Material A,10/Layer Settings,10/80" ); >;
    float3  TextureTint < UiType( Color ); Default3( 1, 1, 1 ); UiGroup( "Material A,10/Layer Settings,10/40" ); >;

    BoolAttribute(bWantsFBCopyTexture, true);
    BoolAttribute(translucent, true);
    
    Texture2D g_tFrameBufferCopyTexture < Attribute("FrameBufferCopyTexture"); SrgbRead( false ); >;

    float4 MainPs( PixelInput i ) : SV_Target0
    {
        // Reinstate UV scale & scroll direction + speed feature from unlit shader
        float2 uv = i.vTextureCoords.xy * TextureScale;
        uv += g_flTime * TextureScrollSpeed * TextureScrollDirection;        

        // Sample these packed textures
        float4 albedo = ColorMap.Sample( g_sAniso, uv ).rgba;
        float4 NormalOpacity = NormalMap.Sample( g_sAniso, uv ).rgba; 
		float3 normal = DecodeNormal( NormalOpacity.rgb ); // Decode RGB of NormalOpacity, since this is where normal map is stored
		float3 rma = g_tRma.Sample( g_sAniso, uv ).rgb;

        // Adjust normal map's intensity according to the user-defined variable. 
        // We shouldn't mess with blue channel, so update only RG components. 
        // This must be done transforming them into world-space normals. 
        normal.rg *= g_flNormalIntensity;

        // Get RG components of a tangent-space normals, corrected for better intensity
        float2 flDistortion = normal.rg * (g_flDistortionIntensity * 8);
        // Calculate viewport UVs for frame buffer, offset by flDistortion value
        float2 ViewportUv = CalculateViewportUv( i.vPositionSs.xy - flDistortion ); 
        float3 frame = g_tFrameBufferCopyTexture.Sample( g_sAniso, ViewportUv ).rgb;

        // Get linearized depth buffer value, use flDistortion to make it inline with frame buffer UVs
        // Depth class doesn't need viewport-corrected UVs, just use screen-space coords directly.
        float flLinear = Depth::GetLinear( i.vPositionSs.xy - flDistortion );
        // Lerp between fog and frame buffer, divide inverted linear depth by distance to define where fog ends
        // in world-space units. 
        frame = lerp( g_vFrameBufferFogColor, frame, smoothstep( 0, g_flFogDensity, 1 - flLinear / g_flFogEndDistanceWs ) );

        // Before passing normal into Material class, it must be transformed from tangent-space
        // to world-space. This is necessary for the standard shading model. 
        float3 NormalTransformed = TransformNormal( normal, i.vNormalWs, i.vTangentUWs, i.vTangentVWs );

        // Initialize a new material object
        Material mat = Material::Init();

        // Fill out the material with all textures we've sampled above
        mat.Albedo = lerp( albedo.rgb, albedo.rgb * TextureTint, albedo.a );
        mat.Normal = NormalTransformed;
        mat.Roughness = rma.r;
        mat.Metalness = rma.g;
        // Put finalized frame buffer pixel as emission, mask out opaque area by inverted opacity map
        // Grants nicer blending and shading without being affected by lighting
        mat.Emission = frame.rgb * (1.0 - NormalOpacity.a);
        mat.AmbientOcclusion = rma.b;
        mat.TintMask = albedo.a;

        // This method returns final, shaded pixel with a type of 'float4'.
        return ShadingModelStandard::Shade( i, mat );
    }
}